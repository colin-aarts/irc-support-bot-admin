// Generated by LiveScript 1.5.0
(function(){
  'use strict';
  var util, fs, js, ignoredUsers, saveIgnoredUsers, split$ = ''.split;
  util = require('util');
  fs = require('fs');
  js = require('js-extensions');
  ignoredUsers = (function(){
    var ignoredUsers;
    ignoredUsers = fs.readFileSync(process.cwd() + "/ignored-users.json", 'utf-8');
    if (ignoredUsers) {
      return JSON.parse(ignoredUsers);
    }
  }.call(this));
  saveIgnoredUsers = function(){
    return fs.writeFile(process.cwd() + "/ignored-users.json", JSON.stringify(ignoredUsers, 'utf-8'));
  };
  module.exports = function(){
    var this$ = this;
    this.register_special_command({
      name: 'raw',
      description: 'Send a raw IRC command',
      admin_only: true,
      fn: function(event, inputData, outputData){
        return this$.irc.raw(inputData.args);
      }
    });
    this.register_special_command({
      name: 'set',
      description: 'Add or update a factoid',
      admin_only: true,
      fn: function(event, inputData, outputData){
        var message, args_match, factoidName, factoidExists, targetFactoid, regexpMatch, regexpFind, regexpReplace, regexpFlags, regexp, factoidContent;
        if (in$('?', inputData.flags)) {
          message = ['Syntax: set[/r!] <factoid-name> = <factoid-content> • Add or update a factoid', '--- This command supports the following flags ---', 'r • regexp: enables regexp mode; <factoid-content> must be a sed-style (s///) substitution literal, conforming to JavaScript regular expression syntax', 'a • alias: alias mode; create an alias to an existing factoid: <factoid-content> becomes a factoid name instead', '! • force: this flag must be set to overwrite an existing factoid when not in regexp mode; otherwise a warning will be issued'];
        } else if (!(args_match = inputData.args.match(/^(.+)\s+=\s+(.+)/))) {
          message = 'Sorry, it looks like you\'re missing some arguments!';
        } else {
          factoidName = args_match[1].trim();
          factoidExists = factoidName in this$.factoids;
          if (in$('a', inputData.flags)) {
            targetFactoid = args_match[2].trim();
            if (!(targetFactoid in this$.factoids)) {
              message = "Sorry, I couldn't find an existing factoid with the name « " + targetFactoid + " » to create an alias for";
            } else if (factoidName === targetFactoid) {
              message = "Sorry, I won't let you create a circular reference :)";
            } else if (factoidExists && !in$('!', inputData.flags)) {
              message = "Sorry, a factoid with the name « " + factoidName + " » already exists. If you want to overwrite this factoid, you must use the '!' flag";
            } else {
              if (/^alias:/.test(this$.factoids[targetFactoid])) {
                targetFactoid = this$.factoids[targetFactoid].replace(/^alias:/, '');
              }
              this$.factoids[factoidName] = "alias:" + targetFactoid;
              this$.save_factoids();
              message = "I successfully created « " + factoidName + " » as an alias for « " + targetFactoid + " »";
            }
          } else if (in$('r', inputData.flags)) {
            if (!factoidExists) {
              message = "Sorry, but I couldn't find a factoid with the name « " + factoidName + " »";
            } else {
              regexpMatch = js.str_reverse(args_match[2].trim()).match(split$.call(/\/^(.*?)(?!\/\\)\/(.*?)(?!\/\\)\/(.+?)(?!\/\\)\/s$/, !regexpMatch
                ? message = 'Sorry, that\'s an invalid regexp argument; the expected format is `<factoid-name> = s/<find>/<replace>/<flags>` where <find> is a JavaScript-compatible regular expression'
                : (regexpMatch = regexpMatch.splice(1).reverse().map(function(item){
                  return js.str_reverse(item);
                }), regexpFind = regexpMatch[0], regexpReplace = regexpMatch[1], regexpFlags = regexpMatch[2], regexpFind = regexpFind.replace(/\/\\\// / g, '/'), regexpReplace = regexpReplace.replace(/\/\\\// / g, '/'), (function(){
                  try {
                    return regexp = new RegExp(regexpFind, regexpFlags);
                  } catch (e$) {}
                }()), !regexp
                  ? message = 'Sorry, the regular expression pattern you provided is invalid'
                  : (this$.factoids[factoidName] = this$.factoids[factoidName].replace(regexp, regexpReplace), this$.save_factoids(), message = "I successfully updated the factoid « " + factoidName + " » with content « " + this$.factoids[factoidName] + " »"))));
            }
          } else {
            if (factoidExists && !in$('!', inputData.flags)) {
              message = "Sorry, a factoid with the name « " + factoidName + " » already exists. If you want to overwrite this factoid, you must use the '!' flag";
            } else {
              factoidContent = args_match[2].trim();
              if (/^alias:/.test(factoidContent)) {
                message = "Sorry, but you can't create factoids of which the content starts with 'alias:'";
              } else {
                this$.factoids[factoidName] = factoidContent;
                this$.save_factoids();
                message = "I successfully " + (factoidExists ? 'updated' : 'added') + " the factoid « " + factoidName + " »";
              }
            }
          }
        }
        return this$.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'del',
      description: 'Delete a factoid',
      admin_only: true,
      fn: function(event, inputData, outputData){
        var message, factoidName, factoidContent, isAlias, factoidOriginalName, factoidOriginalContent, aliases, i$, len$, alias;
        if (in$('?', inputData.flags)) {
          message = ['Syntax: del[/!] <factoid-name> • Delete a factoid', '--- This command supports the following flags ---', '! • force: enables deletion of factoids that have aliases leading to it; will also delete all aliases'];
        } else if (!(inputData.args.trim() in this$.factoids)) {
          message = "Sorry, you can't delete a factoid that doesn't exist!";
        } else {
          factoidName = inputData.args.trim();
          factoidContent = this$.factoids[factoidName];
          isAlias = /^alias:/.test(factoidContent);
          factoidOriginalName = isAlias ? factoidContent.match(/^alias:(.*)/)[1] : factoidName;
          factoidOriginalContent = this$.factoids[factoidOriginalName];
          aliases = this$.factoid_get_aliases(factoidOriginalName);
          if (isAlias) {
            delete this$.factoids[factoidName];
            this$.save_factoids();
            message = "I successfully deleted factoid « " + factoidName + " » which was an alias to « " + factoidOriginalName + " »";
          } else if (!aliases) {
            delete this$.factoids[factoidName];
            this$.save_factoids();
            message = "I successfully deleted factoid « " + factoidName + " » which had the content « " + factoidContent + " »";
          } else {
            if (!in$('!', inputData.flags)) {
              message = "I noticed the factoid you're trying to delete has aliases leading to it (see « " + inputData.trigger + "info " + factoidName + " »). If you want to delete this factoid, and all aliases leading to it, you must specify the '!' flag";
            } else {
              delete this$.factoids[factoidName];
              for (i$ = 0, len$ = aliases.length; i$ < len$; ++i$) {
                alias = aliases[i$];
                delete this$.factoids[alias];
              }
              this$.save_factoids();
              message = "I successfully deleted the factoid « " + factoidName + " » and all aliases leading to it. The deleted factoid's content was « " + factoidContent + " »";
            }
          }
        }
        return this$.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'ignore',
      description: 'Manage the list of ignored users',
      admin_only: true,
      fn: function(event, inputData, outputData){
        var message, i$, ref$, len$, entry, host, ignoreMatch, nick, match_found, index, addMatch;
        if (in$('?', inputData.flags)) {
          message = ['Syntax: ignore[/lrc] [<nick> <host>] • Manage the list of ignored users. When no flag is specified, adds an entry (both <nick> and <host> are required; at most one of these may be the value `null` in order to not use it as a constraint).', '--- This command supports the following flags ---', 'l • list: display a list of ignored users', 'r • remove: remove an entry from the list; must be provided with both <nick> and <host>, as recorded in the list', 'c • clear: clear all entries from the list'];
        } else if (in$('l', inputData.flags)) {
          message = [];
          if (ignoredUsers.length) {
            message.push("I have the following " + ignoredUsers.length + " users ignored:");
            for (i$ = 0, len$ = (ref$ = ignoredUsers).length; i$ < len$; ++i$) {
              entry = ref$[i$];
              host = entry.host === null
                ? '(null)'
                : entry.host;
              message.push("nick: " + entry.nick + " • host: " + host);
            }
          } else {
            message = "I don't currently have anyone on my ignore list";
          }
        } else if (in$('c', inputData.flags)) {
          ignoredUsers = [];
          saveIgnoredUsers();
          message = "I have cleared the list of ignored users";
        } else if (in$('r', inputData.flags)) {
          ignoreMatch = inputData.args.trim().split(' ');
          if (ignoreMatch.length !== 2) {
            message = "Sorry, you must provide both <nick> and <host> and they must match the information in the list";
          } else {
            nick = ignoreMatch[0] === 'null'
              ? null
              : ignoreMatch[0];
            host = ignoreMatch[1] === 'null'
              ? null
              : ignoreMatch[1];
            match_found = false;
            for (i$ = 0, len$ = ignoredUsers.length; i$ < len$; ++i$) {
              index = i$;
              entry = ignoredUsers[i$];
              if (entry.nick === nick && entry.host === host) {
                ignoredUsers.splice(index, 1);
                saveIgnoredUsers();
                match_found = true;
                message = "I have successfully removed the entry from the list of ignored users";
                break;
              }
            }
            if (!match_found) {
              message = "Sorry, I couldn't find that entry in the list of ignored users";
            }
          }
        } else {
          addMatch = inputData.args.trim().split(' ');
          if (addMatch.length !== 2) {
            message = "Sorry, you must provide both <nick> and <host>; at most one of these may be the value `null` in order to not use it as a constraint";
          } else {
            nick = addMatch[0] === 'null'
              ? null
              : addMatch[0];
            host = addMatch[1] === 'null'
              ? null
              : addMatch[1];
            if (nick === null && host === null) {
              message = "Sorry, <nick> and <host> cannot both be `null`";
            } else {
              ignoredUsers.push({
                nick: nick,
                host: host
              });
              saveIgnoredUsers();
              message = "I successfully added the entry to the list of ignored users";
            }
          }
        }
        return this$.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'reload',
      description: 'Reload the bot (it really just kills the bot; if a supervisor is monitoring the process, it\'ll restart',
      admin_only: true,
      fn: function(event, inputData, outputData){
        throw new Error('Force reload!');
      }
    });
    return this.register_message_callback(function(event, inputData, outputData){
      var is_ignored_user, message;
      is_ignored_user = this$.user_match(ignoredUsers, {
        nick: event.person.nick,
        host: event.person.host
      });
      if (is_ignored_user) {
        message = "You're on my ignore list, so don't bother :)";
        this$.send('notice', event.person.nick, message);
        return false;
      } else {
        return true;
      }
    });
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
